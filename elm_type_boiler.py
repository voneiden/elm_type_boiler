import os
import re
from functools import wraps
from pathlib import Path

re_type_definition = (
    r'((?:--.+\n)+)'  # Match comments
    r'type\s+([A-Z][\w]+)\s*='  # Match type name
    r'((?:\s*[A-Z][\w]+\s*(?<!\n)[|])*'  # Match non-last constructor 
    r'(?:\s*[A-Z][\w]+\s*(?:\n|$)))'  # Match last constructor
)

re_type_alias_definition = (
    r'((?:--.+\n)+)'  # Match comments
    r'type alias ([A-Z]\w*)\s*=\s*'  # Match type alias name
    r'{((?:\s*\w+\s*:\s*[\w ]+\s*,?)+)}'  # Match type alias definition
)

reserved_keywords = ["if", "then", "else", "case", "of", "let", "in", "type", "module", "where", "import", "exposing", "as", "port"]


def varname(name):
    var = name[0].lower() + name[1:]
    if var in reserved_keywords:
        var += 'Value'
    return var


def blank(blanks=2):
    buffer = [''] * blanks

    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            r = f(*args, **kwargs)
            r += buffer
            return r

        return wrapper

    return decorator


@blank()
def generate_decoder(name, types):
    """

padDecoder : String -> Decoder Pad
padDecoder pad =
    case pad of
    "VDD" -> Decode.succeed VDD
    "GND" -> Decode.succeed GND
    """
    var = varname(name)
    return [
        f'decode : String -> Decoder {name}',
        f'decode {var} =',
        f'    case fromString {var} of',
        f'        Just {var}_ -> Decode.succeed {var}_',
        f'        Nothing -> Decode.fail <| "Unsupported {var}: " ++ {var}'
    ]


@blank()
def generate_type_list(name, types):
    return [
        f'list : List {name}',
        f'list =',
        f'    [{types[0]}',
        *[f'    ,{t}' for t in types[1:]],
        f'    ]'
    ]


@blank()
def generate_to_string(name, types):
    var = varname(name)
    return [
        f'toString : {name} -> String',
        f'toString {var} =',
        f'    case {var} of',
        *[f'        {t} -> "{t}"' for t in types]
    ]


@blank()
def generate_from_string(name, types):
    var = varname(name)
    return [
        f'fromString : String -> Maybe {name}',
        f'fromString {var} =',
        f'    case {var} of',
        *[f'        "{t}" -> Just {t}' for t in types],
        f'        _ -> Nothing'
    ]


def generate_type_helpers(input_module, output_base_module, output_folder_path, name, types):
    output_module = f'{output_base_module}.{name}'
    buffer = [
        '-- Do not edit!',
        '-- This file was generated by elm_type_boiler',
        '',
        f'module {output_module} exposing (..)',
        f'import {input_module} exposing ({name}(..))',
        f'import Json.Decode as Decode exposing (Decoder)'
    ]

    buffer += generate_type_list(name, types)
    buffer += generate_to_string(name, types)
    buffer += generate_from_string(name, types)
    buffer += generate_decoder(name, types)

    print("BUFFER", buffer)

    output_file_name = os.path.join(output_folder_path, f'{name}.elm')
    with open(output_file_name, 'w') as f:
        f.write('\n'.join(buffer))


def process(input_file_path):
    _path, input_file_name = os.path.split(input_file_path)
    output_folder_path = os.path.join(_path, 'Util')
    print("OUTPUT", output_folder_path)

    input_module = str(os.path.relpath(input_file_path, 'src'))[:-4].replace('/', '.')
    base_module = ".".join(input_module.split(".")[:-1])
    output_base_module = f'{base_module}.Util'

    # input_file_path = os.path.join(src_root, input_module.replace('.', '/') + '.elm')
    # output_folder_path = os.path.join(src_root, output_module.replace('.', '/'))



    with open(input_file_path, 'r') as f:
        input_data = f.read()

    for raw_comments, name, raw_types in re.findall(re_type_definition, input_data):
        print("Found name", name)
        comments = [c[2:].strip() for c in raw_comments.split('\n')]
        types = [t.strip() for t in raw_types.split('|')]
        if '@enum' in comments:
            Path(output_folder_path).mkdir(parents=True, exist_ok=True)
            generate_type_helpers(input_module, output_base_module, output_folder_path, name, types)
    """
    for raw_comments, name, raw_fields in re.findall(re_type_alias_definition, input_data):
        print("Found type alias", name)
        comments = [c[2:].strip() for c in raw_comments.split('\n')]
        types = [t.strip() for t in raw_types.split('|')]
        if '@decoder' in comments:
            pass
    """


if __name__ == '__main__':
    # parser = argparse.ArgumentParser(description='Process some integers.')
    # parser.add_argument('src_root')
    # parser.add_argument('input_file_name')
    # parser.add_argument('output_module')
    # parser_args = parser.parse_args()
    for path in Path('src').rglob('*.elm'):
        process(path)
    # process(parser_args.src_root)
